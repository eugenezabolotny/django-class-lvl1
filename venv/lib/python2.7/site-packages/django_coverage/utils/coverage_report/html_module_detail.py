# -*- encoding: utf-8 -*-
"""
Copyright 2009 55 Minutes (http://www.55minutes.com)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import cgi, os
import re
import subprocess

from django.utils.translation import ugettext as _

from django_coverage.utils.coverage_report.templates import default_module_detail as module_detail
from django_coverage.utils.module_tools.data_storage import Authors
from django_coverage import settings


def get_code_authors(relative_path, cwd=None):
    output = subprocess.check_output(["git", "blame", relative_path], cwd=cwd)
    lines = output.split("\n")
    return lines

def get_code_last_auth(lines, index):
    match = re.search("\s\((\w+)\s", lines[index])
    if match:
        return match.group(1)
    else:
        raise Exception("Author Not Found")


def html_module_detail(filename, m_vars, nav=None):
    """
    Creates a module detail report based on coverage testing at the specified
    filename. If ``nav`` is specified, the nav template will be used as well.

    It uses `templates.default_module_detail` to create the page. The template
    contains the following sections which need to be rendered and assembled into
    the final HTML.

    TOP: Contains the HTML declaration and head information, as well as the
         inline stylesheet. It requires the following variable:
         * %(title)s The module name is probably fitting for this.

    CONTENT_HEADER: The header portion of the body. Requires the following variable:
                    * %(title)s
                    * %(source_file)s File path to the module
                    * %(total_count)d
                    * %(executed_count)d
                    * %(excluded_count)d
                    * %(ignored_count)d
                    * %(percent_covered)0.1f
                    * %(test_timestamp)s

    CONTENT_BODY: Annotated module source code listing. Requires the following variable:
                  * ``%(source_lines)s`` The actual source listing which is generated by
                    looping through each line and concatenanting together rendered
                    ``SOURCE_LINE`` template (see below).

    BOTTOM: Just a closing ``</body></html>``

    SOURCE_LINE: Used to assemble the content of ``%(source_lines)s`` for ``CONTENT_BODY``.
                 Requires the following variables:
                 * ``%(line_status)s`` (ignored, executed, missed, excluded) used as CSS class
                   identifier to style the each source line.
                 * ``%(source_line)s``

    """
    if not nav:
        nav = {}

    module_name = m_vars.module_name

    # 遍历每一个module, 并且将它的coverage可视化出来
    m_vars.source_lines = source_lines = list()
    i = 0

    if settings.COVERAGE_PROCESS_AUTHORS:
        add_auth_coverage = Authors().add_auth_coverage

        module_path = m_vars.get_module_path()
        cwd = m_vars.get_module_dir()
        try:
            code_blame_lines = get_code_authors(module_path, cwd)
        except:
            code_blame_lines = None
    #         import pdb;pdb.set_trace()

        authors = set()

    for i, source_line in enumerate([cgi.escape(l.rstrip()) \
                            for l in open(m_vars.source_file, 'rb').readlines()]):
        if settings.COVERAGE_PROCESS_AUTHORS:
            author = ""
            if code_blame_lines is not None:
                try:
                    author = get_code_last_auth(code_blame_lines, i)
                except:
                    pass
            if author:
                authors.add(author)

            line_status = 'ignored'
            line_idx = i + 1
            if line_idx in m_vars.executed:
                line_status = 'executed'
                # executed, missed, excluded
                add_auth_coverage(author, m_vars, 1, 0, 0)

            if line_idx in m_vars.excluded:
                line_status = 'excluded'
                add_auth_coverage(author, m_vars, 0, 0, 1)

            if line_idx in m_vars.missed:
                line_status = 'missed'
                add_auth_coverage(author, m_vars, 0, 1, 0)

            source_lines.append(module_detail.SOURCE_LINE % vars())
        else:
            line_status = 'ignored'
            if i + 1 in m_vars.executed: line_status = 'executed'
            if i + 1 in m_vars.excluded: line_status = 'excluded'
            if i + 1 in m_vars.missed: line_status = 'missed'
            source_lines.append(module_detail.SOURCE_LINE % vars())

    m_vars.ignored_count = i + 1 - m_vars.total_count
    m_vars.source_lines = os.linesep.join(source_lines)

    if settings.COVERAGE_PROCESS_AUTHORS:
        authors_html = []
        authors_html.append('<a href="javascript:void(0)" class="selected">%s</a>' % _('Full list'))
        for author in authors:
            authors_html.append('<a href="javascript:void(0)">%s</a>' % author)
        authors_html = "".join(authors_html)
    else:
        authors_html = ''

    if 'prev_link' in nav and 'next_link' in nav:
        nav_html = module_detail.NAV % nav
    elif 'prev_link' in nav:
        nav_html = module_detail.NAV_NO_NEXT % nav
    elif 'next_link' in nav:
        nav_html = module_detail.NAV_NO_PREV % nav
    else:
        nav_html = None

    fo = open(filename, 'w+')
    fo.write(module_detail.TOP % m_vars.__dict__)
    if nav and nav_html:
        fo.write(nav_html)

    fo.write(module_detail.CONTENT_HEADER % m_vars.__dict__)
    fo.write(module_detail.CONTENT_FILTER % vars())
    fo.write(module_detail.CONTENT_BODY % m_vars.__dict__)
    if nav and nav_html:
        fo.write(nav_html)
    fo.write(module_detail.BOTTOM)
    fo.close()
